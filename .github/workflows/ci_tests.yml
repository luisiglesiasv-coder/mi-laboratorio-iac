# .github/workflows/ci_tests.yml

name: Ejecutar Pruebas de Infraestructura (CI)

on:
  push:
    branches: [ main ] 

jobs:
  bdd_tests: 
    runs-on: self-hosted 
    
    # Definimos las variables de entorno de Vault y los secretos de AppRole
    env:
      VAULT_ADDR: http://10.0.0.31:8200
      VAULT_ROLE_ID: ${{ secrets.VAULT_ROLE_ID }}
      VAULT_SECRET_ID: ${{ secrets.VAULT_SECRET_ID }}
      
    steps:
    - name: Checkout del CÃ³digo
      uses: actions/checkout@v4 

    # --- DEBUGGING STEP (Para confirmar que el runner ve el archivo) ---
    - name: ðŸ› DEBUG - Mostrar contenido del workflow
      run: |
        echo "Contenido de .github/workflows/ci_tests.yml en el runner:"
        cat .github/workflows/ci_tests.yml
    # ---------------------------------------------
      
    # --- TAREA 1: CONFIGURAR ENTORNO DE PRUEBAS ---
    
    - name: Instalar Vault CLI y JQ (Procesador JSON)
      run: |
        # 1. Instalar Vault CLI
        VAULT_VERSION="1.16.0"
        URL="https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_linux_amd64.zip"
        
        curl -LO "$URL"
        unzip vault_${VAULT_VERSION}_linux_amd64.zip
        
        mkdir -p "$HOME/bin"
        mv vault "$HOME/bin/"
        
        # 2. Instalar JQ (Necesario para parsear la respuesta JSON de Vault)
        curl -Lo "$HOME/bin/jq" https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64
        chmod +x "$HOME/bin/jq"

        # AÃ±adir al PATH para usar 'vault' y 'jq' en pasos posteriores
        echo "$HOME/bin" >> $GITHUB_PATH
        echo "âœ… Cliente Vault y JQ instalados."

    # --- TAREA 2: AUTENTICACIÃ“N Y OBTENCIÃ“N DE SECRETOS ---

    - name: 2.1 Autenticar con Vault (AppRole Login)
      id: vault_login
      run: |
        LOGIN_RESPONSE=$(vault write -format=json auth/approle/login \
          role_id="$VAULT_ROLE_ID" \
          secret_id="$VAULT_SECRET_ID")
        
        VAULT_CLIENT_TOKEN=$(echo "$LOGIN_RESPONSE" | jq -r '.auth.client_token')
        
        if [ -z "$VAULT_CLIENT_TOKEN" ] || [ "$VAULT_CLIENT_TOKEN" == "null" ]; then
          echo "âŒ Error: No se pudo obtener el token de cliente mediante AppRole."
          exit 1
        fi
        
        # Exportamos el token para su uso en los comandos 'vault read'
        echo "::add-mask::$VAULT_CLIENT_TOKEN"
        echo "VAULT_TOKEN=$VAULT_CLIENT_TOKEN" >> $GITHUB_ENV
        echo "âœ… AutenticaciÃ³n AppRole exitosa."

    - name: 2.2 Obtener Credenciales DinÃ¡micas de PostgreSQL
      id: pg_creds
      run: |
        # Usamos -token="$VAULT_TOKEN" para asegurar que el CLI use el token
        SECRET_DATA=$(vault read -token="$VAULT_TOKEN" -format=json database/creds/runner-role)
        
        DB_USER=$(echo "$SECRET_DATA" | jq -r '.data.username')
        DB_PASS=$(echo "$SECRET_DATA" | jq -r '.data.password')
        PG_LEASE_ID=$(echo "$SECRET_DATA" | jq -r '.lease_id') 
        
        if [ -z "$DB_USER" ] || [ "$DB_USER" == "null" ]; then
          echo "âŒ Error: No se pudieron obtener las credenciales de PostgreSQL."
          exit 1
        fi
        
        echo "DB_USER=$DB_USER" >> $GITHUB_ENV
        echo "::add-mask::$DB_PASS"
        echo "DB_PASS=$DB_PASS" >> $GITHUB_ENV
        
        # Exportamos el Lease ID para revocarlo en el paso final
        echo "pg_lease_id=$PG_LEASE_ID" >> $GITHUB_OUTPUT 
        echo "âœ… Credenciales PostgreSQL obtenidas (Lease ID: $PG_LEASE_ID)."

    - name: 2.3 Obtener Credenciales DinÃ¡micas de Redis
      id: redis_creds
      run: |
        # Usamos el rol 'redis-runner-role' configurado en Vault
        REDIS_SECRET_DATA=$(vault read -token="$VAULT_TOKEN" -format=json database/creds/redis-runner-role)
        
        REDIS_USER=$(echo "$REDIS_SECRET_DATA" | jq -r '.data.username')
        REDIS_PASS=$(echo "$REDIS_SECRET_DATA" | jq -r '.data.password')
        REDIS_LEASE_ID=$(echo "$REDIS_SECRET_DATA" | jq -r '.lease_id')
        
        if [ -z "$REDIS_USER" ] || [ "$REDIS_USER" == "null" ]; then
          echo "âŒ Error: No se pudieron obtener las credenciales de Redis."
          exit 1
        fi
        
        # Exportamos las credenciales para su uso en las pruebas
        echo "REDIS_USER=$REDIS_USER" >> $