---
# --- TAREA 0: AUTO-DESBLOQUEO Y HEALTH CHECK ---
# Objetivo: Asegurar que Vault esté activo y desbloqueado (Unsealed) antes de la configuración.

- name: 0.1 Verificar estado de Vault (Health Check)
  ansible.builtin.uri:
    url: "{{ vault_addr }}/v1/sys/health"
    method: GET
    # Códigos 200/429/503 (Abierto, Standby, Sellado) se consideran manejables
    status_code: [200, 429, 503]
  register: vault_health_status

- name: 0.2 Desbloquear Vault si está sellado (status 503)
  ansible.builtin.uri:
    url: "{{ vault_addr }}/v1/sys/unseal"
    method: POST
    body_format: json
    body:
      key: "{{ vault_unseal_key }}"
  # Solo ejecuta si el estado de salud es 503 (Sellado)
  when: vault_health_status.status == 503
  register: unseal_result

# --- TAREA 1: CONFIGURAR MOTOR DE SECRETOS DE BASE DE DATOS ---
# Objetivo: Habilitar el motor 'database/' y configurar la conexión administrativa.

- name: 1.1 Obtener lista de motores de secretos activos para verificación
  community.hashi_vault.vault_read:
    url: "{{ vault_addr }}"
    token: "{{ vault_token }}"
    path: sys/mounts
  register: vault_mounts

- name: 1.2 Habilitar el motor de secretos dinamicos 'database/' (si no existe)
  community.hashi_vault.vault_write:
    url: "{{ vault_addr }}"
    token: "{{ vault_token }}"
    path: sys/mounts/database
    data:
      type: database
      description: "Database secrets engine for PostgreSQL"
  when: "'database/' not in vault_mounts.data"

- name: 1.3 Configurar la conexion administrativa a PostgreSQL
  community.hashi_vault.vault_write:
    url: "{{ vault_addr }}"
    token: "{{ vault_token }}"
    path: database/config/postgresql
    data:
      plugin_name: postgresql-database-plugin
      allowed_roles: runner_role
      connection_url: "postgresql://{{username}}:{{password}}@10.0.0.31:5432/?sslmode=disable"
      username: postgres
      password: "{{ pg_vault_password }}"
  vars:
    username: "{{ '{{username}}' }}"
    password: "{{ '{{password}}' }}"

- name: 1.4 Crear el Rol 'runner_role' para credenciales temporales
  community.hashi_vault.vault_write:
    url: "{{ vault_addr }}"
    token: "{{ vault_token }}"
    path: database/roles/runner_role
    data:
      db_name: postgresql
      creation_statements: |
        CREATE ROLE "{{name}}" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';
        GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA public TO "{{name}}";
      default_ttl: "1h"
      max_ttl: "24h"
  vars:
    name: "{{ '{{name}}' }}"
    password: "{{ '{{password}}' }}"
    expiration: "{{ '{{expiration}}' }}"

# --- TAREA 2: IMPLEMENTAR AUTENTICACIÓN APP ROLE ---
# Objetivo: Crear la identidad que usará el Runner de CI/CD para autenticarse sin el Token Root.

- name: 2.1 Crear la política 'runner-policy' (solo permisos de lectura)
  community.hashi_vault.vault_write:
    url: "{{ vault_addr }}"
    token: "{{ vault_token }}"
    path: sys/policy/runner-policy
    data:
      policy: |
        path "database/creds/runner_role" {
          capabilities = ["read"]
        }
        path "sys/leases/revoke" {
          capabilities = ["update"]
        }

# TAREA: Leemos qué métodos de auth están activos
- name: 2.2.a Obtener lista de métodos de autenticación activos
  community.hashi_vault.vault_read:
    url: "{{ vault_addr }}"
    token: "{{ vault_token }}"
    # Esta es la ruta de la API para listar métodos de auth
    path: sys/auth
  register: vault_auth_methods

# TAREA : Solo habilitamos si no está en la lista
- name: 2.2.b Habilitar el método de autenticación AppRole (si no existe)
  community.hashi_vault.vault_write:
    url: "{{ vault_addr }}"
    token: "{{ vault_token }}"
    path: sys/auth/approle
    data:
      type: approle
    # Verificamos si 'approle/' (con barra al final) ya existe en los datos
  when: "'approle/' not in vault_auth_methods.data"

- name: 2.3 Crear el AppRole 'ci-runner' y vincular la política
  community.hashi_vault.vault_write:
    url: "{{ vault_addr }}"
    token: "{{ vault_token }}"
    path: auth/approle/role/ci-runner
    data:
      policies: ["runner-policy"]
      secret_id_ttl: "5m"
      token_ttl: "1h"

# --- TAREA 3: OBTENER ROLE ID ---
- name: 3.1 Obtener RoleID del AppRole 'ci-runner'
  community.hashi_vault.vault_read:
    url: "{{ vault_addr }}"
    token: "{{ vault_token }}"
    path: auth/approle/role/ci-runner/role-id
  register: ci_runner_role_id
  # Almacenamos el RoleID para usarlo después de forma persistente
  run_once: true
  delegate_to: localhost

- name: 3.2 Generar y obtener SecretID del AppRole 'ci-runner'
  community.hashi_vault.vault_write:
    url: "{{ vault_addr }}"
    token: "{{ vault_token }}"
    path: auth/approle/role/ci-runner/secret-id
  register: ci_runner_secret_id
  # Almacenamos el SecretID para usarlo después de forma persistente
  run_once: true
  delegate_to: localhost


# --- TAREA 4: EXPORTAR Y GUARDAR CREDENCIALES ---
# 4.0 Aseguramos que el directorio 'files' de la raíz existe
- name: 4.0 Asegurar que existe el directorio 'files' en la raíz
  ansible.builtin.file:
    # Usamos '..' para subir un nivel desde 'playbooks/' a la raíz
    path: "{{ playbook_dir }}/../files"
    state: directory
    mode: '0755'
  run_once: true
  delegate_to: localhost

# 4.1 Guardar RoleID en la raíz
- name: 4.1 Guardar RoleID en un archivo local para uso en la CI
  ansible.builtin.copy:
    content: "{{ ci_runner_role_id.data.data.role_id }}"
    # Ruta relativa al playbook: Subimos un nivel y entramos en 'files'
    dest: "{{ playbook_dir }}/../files/ci_runner_role_id.txt"
  run_once: true
  delegate_to: localhost

# 4.2 Guardar SecretID en la raíz
- name: 4.2 Guardar SecretID en un archivo local (REQUIERE CIFRADO)
  ansible.builtin.copy:
    content: "{{ ci_runner_secret_id.data.data.secret_id }}"
    # Ruta relativa al playbook: Subimos un nivel y entramos en 'files'
    dest: "{{ playbook_dir }}/../files/ci_runner_secret_id.txt"
  run_once: true
  delegate_to: localhost